/// <reference lib="webworker" />
/// <reference no-default-lib="true"/>
/// <reference lib="esnext" />

import type { PrecacheEntry } from '@serwist/precaching'
import { cleanupOutdatedCaches, createHandlerBoundToURL, precacheAndRoute } from '@serwist/precaching'
import { NavigationRoute, registerRoute } from '@serwist/routing'

declare let self: ServiceWorkerGlobalScope & {
  __SW_MANIFEST: Array<PrecacheEntry>
}

// Install event: Skip waiting so the new SW takes over immediately
self.addEventListener('install', () => {
  self.skipWaiting()
})

// Activate event: Claim all clients and enable navigation preload
self.addEventListener('activate', (event) => {
  self.clients.claim()
  // Enable navigation preload safely
  if ('navigationPreload' in self.registration) {
    event.waitUntil(self.registration.navigationPreload.enable())
  }
})

// Precache all of the assets generated by your build process
const precache = (self as any).__SW_MANIFEST || []
precacheAndRoute(precache)

// Clean up old cache versions
cleanupOutdatedCaches()

// Set up App Shell-style routing
// Some builds (SSR / Next) may not generate a precached '/index.html'.
// createHandlerBoundToURL throws when the URL is not precached, which
// causes an unhandled exception in the service worker. To avoid that,
// check the precache manifest first and fall back to a simple network
// handler when the app shell isn't present.
const appShellUrl = '/index.html'
let handler: ReturnType<typeof createHandlerBoundToURL> | { handle: (arg: any) => Promise<Response> }
const hasAppShell = Array.isArray(precache) && precache.some((entry: any) => entry && entry.url === appShellUrl)

if (hasAppShell) {
  handler = createHandlerBoundToURL(appShellUrl)
} else {
  // Fallback: route navigation requests to network with preload support
  handler = {
    handle: async ({ event, request }: { event: FetchEvent; request: Request }) => {
      // Try to use navigation preload if available
      try {
        const preloadResponse = event.preloadResponse
        if (preloadResponse) {
          return await preloadResponse
        }
      } catch (e) {
        console.debug('[SW] Navigation preload not available:', e)
      }

      // Fall back to network
      try {
        return await fetch(request)
      } catch (e) {
        return new Response('', { status: 504 })
      }
    },
  }
}

const navigationRoute = new NavigationRoute(handler as any, {
  denylist: [/^\/_/, /\/[^/?]+\.[^/]+$/],
})
registerRoute(navigationRoute)